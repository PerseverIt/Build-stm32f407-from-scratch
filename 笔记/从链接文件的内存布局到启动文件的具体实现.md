# 学习时的思考
本想着一直查阅gnu的一手材料对文件进行分析，但是迫于GNU提供的LD工具有他自己的语法，我又懒得一个个的去查阅指令，当然做这些并不是为了能够手搓启动文件，链接脚本，主要是为了学习其中的设计思想。在分析链接脚本前，我一直以为先分析启动脚本是更优的选择，但是当我分析完链接脚本后，我发现我错的离谱。

### 链接脚本
链接脚本的职能是对内存进行布局，向量中断表必须是放在Flash的最前面，当然本来是CPU只会到RAM的0x00000000和0x00000000读取SP和PC,但是在ST想要扩展Flash的前提下，通过BOOT在Flash启动，把Flash器件的地址空间映射到0x00000000，所以向量中断表可以放到Flash。
然后是代码段也是放到Flash中,代码段包含了所有需要链接的目标文件中.data,还有.data.foo这样的代码段，RAM和Thumb桥接代码段,以及异常处理帧（主要用于C++异常展开和栈回溯，本质是如何从当前栈帧，恢复调用者站帧），并且需要在main执行之前，进行构造函数，main函数返回后进行析构函数，但是裸机嵌入式一般不会返回，一直跑在死循环。
在然后是只读数据段，比如字符串切片，常量就是放到只读数据段，也是放到Flash中
在然后是异常展开表和异常索引表，异常索引表的表项会指向异常展开表的某条展开信息，通过这个信息恢复调用者站帧(不是很重要？),当然这两个段也是放到Flash中。
然后是预初始化数组和构造函数指针数组，析构函数指针数组，这3个数组段的实现，也是放到flash中
.data段是初始值放到flash中，运行时是在ram去读取数据，这就引出了LMA加载地址和VMA运行地址
然后是ccmram段，这个段给我的感觉就是个ram,这个ram怎么用暂时没用过，因为我看启动代码里也没有搬运Flash的数据到这个ram中,自然这个段也是初始值放到Flash中，运行时到Ram中读取。
然后是bss段，这个段可以直接放到ram中，因为初始化为0是一个很自然的过程，不需要放到Flash中
最后是用户堆和栈的段，堆向下增长，栈向上增长，地址上低下高
内存分布结束后，就是垃圾回收，把各种运行时库进行回收。

接下来仔细学习下runtime,挺有意思
