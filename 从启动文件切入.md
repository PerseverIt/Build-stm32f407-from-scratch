# 🛠️ 从启动文件切入：底层开发的“第一刀”

> **Date:** 2026-02-21

> **Topic:** ARM 架构底层切入点分析

---

## 💡 理论 vs 实践：别掉进“等学完再做”的陷阱

学习了几天理论，我一直在反思：如果非要等理论全部学完再去实践，那绝对是南辕北辙。

* **痛点**：理论是灰色的，只有代码跑起来才是绿色的。
* **感悟**：在对理论有个基础概念的同时，如何迅速将其应用到实际并混个“脸熟”，这才是打破学习焦虑的关键。

---

## 🎯 为什么选“启动文件”作为切入点？

我对比了两个方案：

| 方案               | 优劣分析              | 结论         |
| ---------------- | ----------------- | ---------- |
| **CMSIS-Core**   | 贴合架构理论，但复杂度简直是倍增。 | 太深，容易劝退。   |
| **Startup File** | 离硬件最近，是 C 环境的起点。  | **最佳切入点**。 |

虽然选了启动文件，但这一块的“深水区”依然让人头大：

1. **领域极宽**：从 GNU 工具链的使用到编译原理的底层逻辑。
2. **不手搓也烦**：就算不从零手搓，光是看懂厂商给的 `.s` 文件也需要大量工作。
3. **汇编代差**：ARM 汇编和 x86 的差距大到怀疑人生，还得不断查阅那些晦涩的 ARM 专属伪指令。

---

## 🚧 当前的学习策略：先抓“有什么”，再问“为什么”

面对内存布局和中断系统这些硬骨头，我决定调整战术：

1. **先关注“有什么”**：先看代码里定义了什么段、向量表里排了什么，不去纠结每一行汇编的微操。
2. **战略性跳过**：各种中断如果讲得太细，会严重阻碍进度。
3. **推迟决战**：具体的异常处理理论，留到后面分析 CMSIS 内核时再仔细死磕。

---

### 📅 下一步

* [ ] 对照 `startup_stm32f407xx.s`，查阅 GNU 汇编 `.word` 和 `.section` 的具体用法。
* [ ] 在 Linker Script 里尝试改一下栈的大小，看看编译出来的镜像有什么变化。



